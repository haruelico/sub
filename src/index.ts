import { app, BrowserWindow, ipcMain } from 'electron';
// import * as recorder from 'node-record-lpcm16'
// const recorder = require("node-record-lpcm16")
import { Sox } from "./lib/sox"
import speech from "@google-cloud/speech"
import got from "got"
import throttle from "lodash/throttle"
import { Writable } from "stream"
// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
const sox = new Sox()
const speechClient = new speech.SpeechClient()

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) { // eslint-disable-line global-require
  app.quit();
}

const createWindow = (): BrowserWindow => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      contextIsolation: true,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY
    }
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  return mainWindow
};

const requestToDeepl = async (text: string): Promise<object> => {
  try {
    const data = await got.post(`https://api-free.deepl.com/v2/translate?auth_key=${process.env.DEEPL_API_KEY}`, {
      body: `auth_key=${process.env.DEEPL_API_KEY}&text=${text}&source_lang=JA&target_lang=EN-US`,
      headers: {
        'Content-Type': "application/x-www-form-urlencoded"
      }
    }).json()
    return data as object
  } catch (e) {
    console.warn(e)
  }
}

const streamingLimit = 2000000
let bridgingOffset = 0
let restartCounter = 0
let isFinalEndTime = 0
let lastTranscriptWasFinal = false
let newStream = true
let audioInput: any[] = []
let lastAudioInput: any[] = []
let finalRequestEndTime = 0
let resultEndTime = 0
let recognizeStream = speechClient.streamingRecognize({
  config: {
    encoding: "LINEAR16",
    sampleRateHertz: 16000,
    languageCode: "ja-JP"
  },
  interimResults: true,
})

// @ts-ignore
const speechCallback = stream => {
  resultEndTime = stream.results[0].resultEndTime.seconds * 1000 +
    Math.round(stream.results[0].resultEndTime.nanos / 1000000)

  const correctedTime = resultEndTime - bridgingOffset + streamingLimit * restartCounter;
  let stdoutText = ''
  if (stream.results[0] && stream.results[0].alternatives[0]) {
    stdoutText = correctedTime + ': ' + stream.results[0].alternatives[0].transcript
  }

  if (stream.results[0].isFinal) {
    isFinalEndTime = resultEndTime
    lastTranscriptWasFinal = true
  } else {
    lastTranscriptWasFinal = false
  }
}

const audioInputStreamTransform = new Writable({
  write(chunk, encoding, next) {
    if (newStream && lastAudioInput.length !== 0) {
      const chunkTime = streamingLimit / lastAudioInput.length
      if (chunkTime !== 0) {
        if (bridgingOffset < 0) {
          bridgingOffset = 0
        }
        if (bridgingOffset > finalRequestEndTime) {
          bridgingOffset = finalRequestEndTime
        }
        const chunkFromMS = Math.floor((finalRequestEndTime = bridgingOffset) / chunkTime)
        bridgingOffset = Math.floor((lastAudioInput.length - chunkFromMS) * chunkTime)

        for (let i = chunkFromMS; i < lastAudioInput.length; i++) {
          // @ts-ignore
          recognizeStream.write(lastAudioInput[i])
        }
      }
      newStream = false
    }

    // @ts-ignore
    audioInput.push(chunk)

    if (recognizeStream) {
      recognizeStream.write(chunk)
    }

    next()
  },
  final() {
    if (recognizeStream) {
      recognizeStream.end()
    }
  }
})

function restartStream() {
  if (recognizeStream) {
    recognizeStream.end()
    recognizeStream.removeListener('data', speechCallback)
    recognizeStream = null

  }
  if (resultEndTime > 0) {
    finalRequestEndTime = isFinalEndTime
  }
  resultEndTime = 0
  lastAudioInput = []
  // @ts-ignore
  lastAudioInput = audioInput
  restartCounter++

  if (!lastTranscriptWasFinal) {
    //
  }

  newStream = true
  // @ts-ignore
  startStream();
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  const window = createWindow();

  (async () => {
    while (true) {
      try {
        await new Promise((resolve, reject) => {
          console.log("start recognize")
          const recognizeStream = speechClient.streamingRecognize({
            config: {
              encoding: "LINEAR16",
              sampleRateHertz: 16000,
              languageCode: "ja-JP"
            },
            interimResults: true,
            // singleUtterance: true
          }).on("error", console.error).on("data", throttle(data => {
            let text = data.results[0] && data.results[0].alternatives[0] ? data.results[0].alternatives[0].transcript : 'none'
            requestToDeepl(text).then(translate => {
              window.webContents.send("speech-to-text", { ...translate, original: text })
            }).catch(() => {
              console.warn("deepl timeout")
            })
          }, 3000, { trailing: true }))

          sox.start().stream().on('error', e => {
            console.error(e)
            sox.stop()
            reject('error')
          }).pipe(recognizeStream)

          setTimeout(() => {
            sox.stop()
            resolve(true)
          }, streamingLimit)
        })
      } catch (err) {
        console.error(err)
      }
    }
  })();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    sox.stop()
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
